---
import { Icon } from "astro-icon/components";
---

<header class="fixed top-0 left-0 w-full z-50 border-b border-slate-800/50">
  <!-- Simplified background for tool interface -->
  <div class="absolute inset-0 bg-slate-900/95 backdrop-blur-md"></div>

  <div class="relative max-w-none px-6">
    <div class="h-16 flex items-center justify-between">
      <!-- Enhanced brand logo with gradient (consistent with homepage) -->
      <a href="/" class="group relative">
        <div class="text-xl font-bold tracking-tight">
          <span
            class="bg-gradient-to-r from-violet-400 via-purple-400 to-blue-400 bg-clip-text text-transparent">
            Describe
          </span>
          <span
            class="text-white/70 group-hover:text-white/90 transition-colors duration-300">
            Music
          </span>
          <span class="text-violet-400/80">.</span>
        </div>
        <!-- Subtle glow effect on hover -->
        <div
          class="absolute inset-0 bg-gradient-to-r from-violet-500/20 to-blue-500/20 rounded-lg blur-xl opacity-0 group-hover:opacity-100 transition-opacity duration-500 -z-10">
        </div>
      </a>

      <!-- Right side navigation -->
      <nav class="flex items-center gap-4">
        <!-- Save/Export actions (only show when analysis results are available) -->
        <div
          class="hidden items-center gap-2"
          id="export-share-container"
          style="display: none;">
          <!-- Export Dropdown -->
          <div class="relative" id="export-dropdown">
            <button
              onclick="toggleExportDropdown()"
              class="inline-flex items-center gap-2 px-3 py-1.5 text-sm text-slate-400 hover:text-white border border-slate-700 rounded-md hover:border-slate-600 transition-all duration-300">
              <Icon
                name="heroicons:document-arrow-down-20-solid"
                class="w-4 h-4"
              />
              Export
              <Icon name="heroicons:chevron-down-20-solid" class="w-3 h-3" />
            </button>

            <!-- Export Dropdown Menu -->
            <div
              id="export-menu"
              class="absolute right-0 mt-2 w-48 bg-slate-800/95 backdrop-blur-md border border-slate-700 rounded-lg shadow-xl opacity-0 invisible transform scale-95 transition-all duration-200 z-50">
              <div class="p-2">
                <button
                  onclick="exportAsJSON()"
                  class="w-full flex items-center gap-3 px-3 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-700/50 rounded-md transition-all duration-200">
                  <Icon
                    name="heroicons:document-text-20-solid"
                    class="w-4 h-4"
                  />
                  Export as JSON
                </button>
                <button
                  onclick="exportAsCSV()"
                  class="w-full flex items-center gap-3 px-3 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-700/50 rounded-md transition-all duration-200">
                  <Icon name="heroicons:table-cells-20-solid" class="w-4 h-4" />
                  Export as CSV
                </button>
                <button
                  onclick="exportReport()"
                  class="w-full flex items-center gap-3 px-3 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-700/50 rounded-md transition-all duration-200">
                  <Icon name="heroicons:document-20-solid" class="w-4 h-4" />
                  Generate Report
                </button>
                <hr class="my-2 border-slate-600" />
                <button
                  onclick="copyAnalysisData()"
                  class="w-full flex items-center gap-3 px-3 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-700/50 rounded-md transition-all duration-200">
                  <Icon name="heroicons:clipboard-20-solid" class="w-4 h-4" />
                  Copy to Clipboard
                </button>
              </div>
            </div>
          </div>

          <!-- Share Dropdown -->
          <div class="relative" id="share-dropdown">
            <button
              onclick="toggleShareDropdown()"
              class="inline-flex items-center gap-2 px-3 py-1.5 text-sm text-slate-400 hover:text-white border border-slate-700 rounded-md hover:border-slate-600 transition-all duration-300">
              <Icon name="heroicons:share-20-solid" class="w-4 h-4" />
              Share
              <Icon name="heroicons:chevron-down-20-solid" class="w-3 h-3" />
            </button>

            <!-- Share Dropdown Menu -->
            <div
              id="share-menu"
              class="absolute right-0 mt-2 w-56 bg-slate-800/95 backdrop-blur-md border border-slate-700 rounded-lg shadow-xl opacity-0 invisible transform scale-95 transition-all duration-200 z-50">
              <div class="p-2">
                <button
                  onclick="copyShareLink()"
                  class="w-full flex items-center gap-3 px-3 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-700/50 rounded-md transition-all duration-200">
                  <Icon name="heroicons:link-20-solid" class="w-4 h-4" />
                  Copy Share Link
                </button>
                <button
                  onclick="shareViaEmail()"
                  class="w-full flex items-center gap-3 px-3 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-700/50 rounded-md transition-all duration-200">
                  <Icon name="heroicons:envelope-20-solid" class="w-4 h-4" />
                  Share via Email
                </button>
                <hr class="my-2 border-slate-600" />
                <button
                  onclick="shareToTwitter()"
                  class="w-full flex items-center gap-3 px-3 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-700/50 rounded-md transition-all duration-200">
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                    <path
                      d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"
                    ></path>
                  </svg>
                  Share on Twitter
                </button>
                <button
                  onclick="shareToLinkedIn()"
                  class="w-full flex items-center gap-3 px-3 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-700/50 rounded-md transition-all duration-200">
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                    <path
                      d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"
                    ></path>
                  </svg>
                  Share on LinkedIn
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Mobile menu button -->
        <button
          class="md:hidden p-2 text-slate-400 hover:text-white rounded-md hover:bg-slate-800 transition-all duration-300">
          <Icon name="heroicons:bars-3-20-solid" class="w-5 h-5" />
        </button>
      </nav>
    </div>
  </div>
</header>

<style>
  /* Minimize visual noise for tool interface */
  header {
    font-feature-settings:
      "tnum" on,
      "lnum" on; /* Tabular numbers for better alignment */
  }

  /* Subtle animation for the activity indicator */
  @keyframes pulse-soft {
    0%,
    100% {
      opacity: 0.4;
    }
    50% {
      opacity: 1;
    }
  }

  .animate-pulse {
    animation: pulse-soft 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  /* Custom gradient animation for brand logo (consistent with homepage) */
  @keyframes gradient-shift {
    0%,
    100% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
  }

  header a[href="/"]:hover span:first-child {
    background-size: 200% 200%;
    animation: gradient-shift 3s ease infinite;
  }
</style>

<script>
  // Dropdown functionality
  function toggleExportDropdown() {
    const menu = document.getElementById("export-menu");
    if (!menu) return;

    const isVisible = !menu.classList.contains("invisible");

    // Close all dropdowns first
    closeAllDropdowns();

    if (!isVisible) {
      menu.classList.remove("invisible", "opacity-0", "scale-95");
      menu.classList.add("opacity-100", "scale-100");
    }
  }

  function toggleShareDropdown() {
    const menu = document.getElementById("share-menu");
    if (!menu) return;

    const isVisible = !menu.classList.contains("invisible");

    // Close all dropdowns first
    closeAllDropdowns();

    if (!isVisible) {
      menu.classList.remove("invisible", "opacity-0", "scale-95");
      menu.classList.add("opacity-100", "scale-100");
    }
  }

  // Store analysis result locally as backup
  let localAnalysisResult: any = null;

  // Also store in a different global property as backup
  (window as any).backupAnalysisResult = null;

  // Make functions globally accessible
  (window as any).toggleExportDropdown = toggleExportDropdown;
  (window as any).toggleShareDropdown = toggleShareDropdown;

  function closeAllDropdowns() {
    const dropdowns = ["export-menu", "share-menu"];
    dropdowns.forEach((id) => {
      const menu = document.getElementById(id);
      if (menu) {
        menu.classList.add("invisible", "opacity-0", "scale-95");
        menu.classList.remove("opacity-100", "scale-100");
      }
    });
  }

  // Close dropdowns when clicking outside
  document.addEventListener("click", function (event) {
    const exportDropdown = document.getElementById("export-dropdown");
    const shareDropdown = document.getElementById("share-dropdown");
    const target = event.target as Element;

    if (!exportDropdown?.contains(target) && !shareDropdown?.contains(target)) {
      closeAllDropdowns();
    }
  });

  // Function to toggle export/share buttons visibility
  function toggleExportShareButtons(show: boolean) {
    const container = document.getElementById("export-share-container");
    if (container) {
      if (show) {
        // Show buttons with proper responsive classes
        container.style.display = "";
        container.className = "hidden md:flex items-center gap-2";
        console.log("ðŸ”§ Export buttons shown");
      } else {
        // Hide buttons completely
        container.style.display = "none";
        container.className = "hidden items-center gap-2";
        console.log("ðŸ”§ Export buttons hidden");
      }
    }
  }

  // Function to check if we should show export buttons
  // Show buttons when: (has analysis data) AND (on results page OR history sidebar is showing results)
  function shouldShowExportButtons(): boolean {
    // Check if we have any analysis data available
    const hasAnalysisData = !!(
      (window as any).currentAnalysisResult ||
      (window as any).backupAnalysisResult ||
      localAnalysisResult
    );

    if (!hasAnalysisData) {
      return false;
    }

    // Check if we're currently showing analysis results
    // This could be either:
    // 1. Main analysis results page (DashboardSection is visible)
    // 2. History sidebar is open and showing a result
    const isDashboardVisible =
      document.querySelector('[data-component="dashboard"]') !== null;
    const isHistorySidebarOpen =
      document.querySelector('[data-sidebar="history"][data-state="open"]') !==
      null;
    const isHistoryItemSelected =
      document.querySelector('[data-history-item="selected"]') !== null;

    const shouldShow =
      isDashboardVisible || (isHistorySidebarOpen && isHistoryItemSelected);

    console.log("ðŸ”§ Export button check:", {
      hasAnalysisData,
      isDashboardVisible,
      isHistorySidebarOpen,
      isHistoryItemSelected,
      shouldShow,
    });

    return shouldShow;
  }

  // Listen for analysis result updates from React component
  window.addEventListener("analysisResultReady", function (event: any) {
    console.log(
      "ðŸ”§ Analysis result ready event received for:",
      event.detail?.filename
    );

    // Store in multiple locations for reliability
    (window as any).currentAnalysisResult = event.detail;
    (window as any).backupAnalysisResult = event.detail;
    localAnalysisResult = event.detail;

    // Show export/share buttons when analysis is available
    toggleExportShareButtons(true);
  });

  // Listen for analysis result cleared event
  window.addEventListener("analysisResultCleared", function () {
    console.log("ðŸ”§ Analysis result cleared event received");

    // Clear local storage
    localAnalysisResult = null;

    // Hide export/share buttons when no analysis is available
    toggleExportShareButtons(false);
  });

  // Track current visibility state to avoid unnecessary updates
  let currentButtonsVisible = false;

  // Check periodically if we should show/hide export buttons
  setInterval(() => {
    const shouldShow = shouldShowExportButtons();
    if (shouldShow !== currentButtonsVisible) {
      console.log(
        "ðŸ”§ Button visibility changed from",
        currentButtonsVisible,
        "to",
        shouldShow
      );
      currentButtonsVisible = shouldShow;
      toggleExportShareButtons(shouldShow);
    }
  }, 1000);

  // Initial check on page load
  setTimeout(() => {
    const shouldShow = shouldShowExportButtons();
    console.log("ðŸ”§ Initial check - should show buttons:", shouldShow);
    currentButtonsVisible = shouldShow;
    toggleExportShareButtons(shouldShow);
  }, 500);

  // Get current analysis data from React component state
  function getCurrentAnalysisData() {
    // Try to get current analysis result from window object (set by React component)
    const currentResult = (window as any).currentAnalysisResult;

    // Debug logging with timestamp
    console.log(
      `ðŸ› Export Debug [${new Date().toISOString()}] - window.currentResult:`,
      currentResult
    );
    console.log(
      `ðŸ› Export Debug [${new Date().toISOString()}] - backupAnalysisResult:`,
      (window as any).backupAnalysisResult
    );
    console.log(
      `ðŸ› Export Debug [${new Date().toISOString()}] - localAnalysisResult:`,
      localAnalysisResult
    );
    console.log(
      `ðŸ› Export Debug [${new Date().toISOString()}] - filename:`,
      currentResult?.filename ||
        (window as any).backupAnalysisResult?.filename ||
        localAnalysisResult?.filename
    );

    // Use backups if primary global is null
    const result =
      currentResult ||
      (window as any).backupAnalysisResult ||
      localAnalysisResult;

    if (!result) {
      // Return placeholder data if no current analysis is available
      return {
        filename: "no-analysis-available.mp3",
        timestamp: new Date().toISOString(),
        duration: 0,
        format: "Unknown",
        basicInfo: {
          genre: "Unknown",
          mood: "Unknown",
          bpm: 0,
          key: "Unknown",
          energy: 0,
          valence: 0,
          danceability: 0,
        },
        emotions: {
          happy: 0,
          sad: 0,
          angry: 0,
          calm: 0,
          excited: 0,
        },
        quality: {
          overall: 0,
          clarity: 0,
          loudness: 0,
          dynamic_range: 0,
          noise_level: 0,
        },
        tags: ["no-analysis-available"],
      };
    }

    // Convert the React component data to export format
    return {
      filename: result.filename,
      timestamp: result.timestamp,
      duration: result.duration,
      fileSize: result.fileSize,
      format: result.format,
      contentType: result.contentType,
      basicInfo: {
        genre: result.basicInfo.genre,
        mood: result.basicInfo.mood,
        bpm: result.basicInfo.bpm,
        key: result.basicInfo.key,
        energy: result.basicInfo.energy,
        valence: result.basicInfo.valence,
        danceability: result.basicInfo.danceability,
        instrumentalness: result.basicInfo.instrumentalness,
        speechiness: result.basicInfo.speechiness,
        acousticness: result.basicInfo.acousticness,
        liveness: result.basicInfo.liveness,
        loudness: result.basicInfo.loudness,
      },
      voiceAnalysis: result.voiceAnalysis,
      soundEffects: result.soundEffects,
      emotions: result.emotions,
      structure: result.structure,
      quality: result.quality,
      similarity: result.similarity,
      tags: result.tags || [],
      aiDescription: result.aiDescription,
      processingTime: result.processingTime,
    };
  }

  // Helper function to get clean filename without extension
  function getCleanFilename(filename) {
    if (!filename || filename === "no-analysis-available.mp3") {
      return "audio-analysis";
    }

    // Remove file extension
    const lastDotIndex = filename.lastIndexOf(".");
    if (lastDotIndex > 0) {
      return filename.substring(0, lastDotIndex);
    }
    return filename;
  }

  // Export functions
  function exportAsJSON() {
    const data = getCurrentAnalysisData();
    const cleanFilename = getCleanFilename(data.filename);
    const jsonString = JSON.stringify(data, null, 2);
    downloadFile(
      `${cleanFilename}-analysis.json`,
      jsonString,
      "application/json"
    );
    closeAllDropdowns();
  }

  function exportAsCSV() {
    const data = getCurrentAnalysisData();
    const cleanFilename = getCleanFilename(data.filename);
    const csv = convertToCSV(data);
    downloadFile(`${cleanFilename}-analysis.csv`, csv, "text/csv");
    closeAllDropdowns();
  }

  function exportReport() {
    const data = getCurrentAnalysisData();
    const cleanFilename = getCleanFilename(data.filename);
    const report = generateTextReport(data);
    downloadFile(`${cleanFilename}-report.txt`, report, "text/plain");
    closeAllDropdowns();
  }

  function copyAnalysisData() {
    const data = getCurrentAnalysisData();
    const summary = generateSummary(data);
    navigator.clipboard.writeText(summary).then(() => {
      showNotification("Analysis data copied to clipboard!");
    });
    closeAllDropdowns();
  }

  // Share functions
  function copyShareLink() {
    const data = getCurrentAnalysisData();
    if (!data || !data.id) {
      showNotification("No analysis result available to share");
      closeAllDropdowns();
      return;
    }
    // Use the correct route with analysis ID (ensure trailing slash)
    const shareUrl = `${window.location.origin}/analysis/${data.id}/`;
    navigator.clipboard.writeText(shareUrl).then(() => {
      showNotification("Share link copied to clipboard", 'success');
    }).catch(() => {
      showNotification("Failed to copy to clipboard", 'error');
    });
    closeAllDropdowns();
  }

  function shareViaEmail() {
    const data = getCurrentAnalysisData();
    const cleanFilename = getCleanFilename(data.filename);
    const subject = `Audio Analysis Results: ${cleanFilename}`;
    const body = generateEmailBody(data);
    const mailto = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    window.open(mailto);
    closeAllDropdowns();
  }

  function shareToTwitter() {
    const data = getCurrentAnalysisData();
    const cleanFilename = getCleanFilename(data.filename);
    const text = `Just analyzed "${cleanFilename}" with Describe Music! ðŸŽµ Genre: ${data.basicInfo.genre}, BPM: ${data.basicInfo.bpm}, Mood: ${data.basicInfo.mood} âš¡ #AudioAnalysis #AI`;
    const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
    window.open(url, "_blank");
    closeAllDropdowns();
  }

  function shareToLinkedIn() {
    const data = getCurrentAnalysisData();
    const cleanFilename = getCleanFilename(data.filename);
    const summary = `Just completed an AI-powered audio analysis of "${cleanFilename}" using Describe Music. Key insights: ${data.basicInfo.genre} genre, ${data.basicInfo.bpm} BPM, ${data.basicInfo.mood} mood.`;
    // Ensure URL ends with trailing slash
    const shareUrl = window.location.href.endsWith('/') ? window.location.href : `${window.location.href}/`;
    const url = `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(shareUrl)}&summary=${encodeURIComponent(summary)}`;
    window.open(url, "_blank");
    closeAllDropdowns();
  }

  // Utility functions
  function downloadFile(filename, content, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showNotification(`${filename} downloaded successfully!`);
  }

  function convertToCSV(data) {
    const rows = [
      ["Category", "Property", "Value", "Notes"],

      // File Information
      ["File Info", "Filename", data.filename, "Original audio file"],
      [
        "File Info",
        "Analysis Date",
        new Date(data.timestamp).toLocaleString(),
        "When analysis was performed",
      ],
      [
        "File Info",
        "Duration",
        `${Math.floor(data.duration / 60)}:${(data.duration % 60).toString().padStart(2, "0")}`,
        "Audio length in MM:SS",
      ],
      [
        "File Info",
        "File Size",
        data.fileSize || "Unknown",
        "Size of audio file",
      ],
      ["File Info", "Format", data.format || "Unknown", "Audio file format"],
      [
        "File Info",
        "Processing Time",
        `${data.processingTime || 0} seconds`,
        "AI analysis processing time",
      ],

      // Basic Musical Analysis
      [
        "Music Analysis",
        "Genre",
        data.basicInfo?.genre || "Unknown",
        "Primary musical genre",
      ],
      [
        "Music Analysis",
        "Mood",
        data.basicInfo?.mood || "Unknown",
        "Overall emotional mood",
      ],
      [
        "Music Analysis",
        "BPM",
        data.basicInfo?.bpm || "Unknown",
        "Beats per minute (tempo)",
      ],
      [
        "Music Analysis",
        "Key",
        data.basicInfo?.key || "Unknown",
        "Musical key signature",
      ],
      [
        "Music Analysis",
        "Energy",
        Math.round((data.basicInfo?.energy || 0) * 100) + "%",
        "Energy level (0-100%)",
      ],
      [
        "Music Analysis",
        "Valence",
        Math.round((data.basicInfo?.valence || 0) * 100) + "%",
        "Musical positivity (0-100%)",
      ],
      [
        "Music Analysis",
        "Danceability",
        Math.round((data.basicInfo?.danceability || 0) * 100) + "%",
        "How suitable for dancing (0-100%)",
      ],
      [
        "Music Analysis",
        "Instrumentalness",
        Math.round((data.basicInfo?.instrumentalness || 0) * 100) + "%",
        "Lack of vocals (0-100%)",
      ],
      [
        "Music Analysis",
        "Speechiness",
        Math.round((data.basicInfo?.speechiness || 0) * 100) + "%",
        "Presence of spoken words (0-100%)",
      ],
      [
        "Music Analysis",
        "Acousticness",
        Math.round((data.basicInfo?.acousticness || 0) * 100) + "%",
        "Acoustic vs electronic (0-100%)",
      ],
      [
        "Music Analysis",
        "Liveness",
        Math.round((data.basicInfo?.liveness || 0) * 100) + "%",
        "Live performance detection (0-100%)",
      ],

      // Audio Quality
      [
        "Audio Quality",
        "Overall Score",
        `${data.quality?.overall || 0}/10`,
        "Overall audio quality rating",
      ],
      [
        "Audio Quality",
        "Clarity",
        `${data.quality?.clarity || 0}/10`,
        "Audio clarity and definition",
      ],
      [
        "Audio Quality",
        "Loudness",
        `${data.quality?.loudness || 0} dB`,
        "RMS loudness level",
      ],
      [
        "Audio Quality",
        "Dynamic Range",
        `${data.quality?.dynamic_range || 0}/10`,
        "Difference between loud and quiet parts",
      ],
      [
        "Audio Quality",
        "Noise Level",
        `${data.quality?.noise_level || 0}%`,
        "Background noise percentage",
      ],
      [
        "Audio Quality",
        "Distortion",
        `${data.quality?.distortion || 0}%`,
        "Audio distortion level",
      ],
      [
        "Audio Quality",
        "Frequency Balance",
        `${data.quality?.frequency_balance || 0}/10`,
        "Balance across frequency spectrum",
      ],
    ];

    // Add Emotional Analysis if available
    if (data.emotions) {
      Object.entries(data.emotions).forEach(([emotion, value]) => {
        rows.push([
          "Emotions",
          emotion.charAt(0).toUpperCase() + emotion.slice(1),
          Math.round((value as number) * 100) + "%",
          `${emotion} emotion intensity`,
        ]);
      });
    }

    // Add Content Type if available
    if (data.contentType) {
      rows.push([
        "Content Type",
        "Primary Type",
        data.contentType.primary || "Unknown",
        "Main content classification",
      ]);
      rows.push([
        "Content Type",
        "Confidence",
        Math.round((data.contentType.confidence || 0) * 100) + "%",
        "Classification confidence",
      ]);
      rows.push([
        "Content Type",
        "Description",
        data.contentType.description || "No description",
        "Detailed content description",
      ]);
    }

    // Add Voice Analysis if available
    if (data.voiceAnalysis && data.voiceAnalysis.hasVoice) {
      rows.push([
        "Voice Analysis",
        "Has Voice",
        data.voiceAnalysis.hasVoice ? "Yes" : "No",
        "Voice detection result",
      ]);
      rows.push([
        "Voice Analysis",
        "Speaker Count",
        data.voiceAnalysis.speakerCount || 0,
        "Number of detected speakers",
      ]);

      if (data.voiceAnalysis.genderDetection) {
        rows.push([
          "Voice Analysis",
          "Primary Gender",
          data.voiceAnalysis.genderDetection.primary || "Unknown",
          "Detected speaker gender",
        ]);
        rows.push([
          "Voice Analysis",
          "Gender Confidence",
          Math.round(
            (data.voiceAnalysis.genderDetection.confidence || 0) * 100
          ) + "%",
          "Gender detection confidence",
        ]);
      }

      if (data.voiceAnalysis.speakerEmotion) {
        rows.push([
          "Voice Analysis",
          "Speaker Emotion",
          data.voiceAnalysis.speakerEmotion.primary || "Unknown",
          "Primary emotional tone",
        ]);
        rows.push([
          "Voice Analysis",
          "Emotion Confidence",
          Math.round(
            (data.voiceAnalysis.speakerEmotion.confidence || 0) * 100
          ) + "%",
          "Emotion detection confidence",
        ]);
      }

      if (data.voiceAnalysis.speechClarity) {
        rows.push([
          "Voice Analysis",
          "Speech Clarity",
          `${data.voiceAnalysis.speechClarity.score || 0}/10`,
          "Overall speech clarity score",
        ]);
        rows.push([
          "Voice Analysis",
          "Speaking Pace",
          data.voiceAnalysis.speechClarity.pace || "Unknown",
          "Speaking speed assessment",
        ]);
        rows.push([
          "Voice Analysis",
          "Volume Level",
          data.voiceAnalysis.speechClarity.volume || "Unknown",
          "Voice volume level",
        ]);
      }
    }

    // Add Sound Effects if available
    if (
      data.soundEffects &&
      data.soundEffects.detected &&
      data.soundEffects.detected.length > 0
    ) {
      data.soundEffects.detected.forEach((sound, index) => {
        rows.push([
          "Sound Effects",
          `Effect ${index + 1} - Type`,
          sound.type || "Unknown",
          `Detected sound effect type`,
        ]);
        rows.push([
          "Sound Effects",
          `Effect ${index + 1} - Category`,
          sound.category || "Unknown",
          `Sound category classification`,
        ]);
        rows.push([
          "Sound Effects",
          `Effect ${index + 1} - Confidence`,
          Math.round((sound.confidence || 0) * 100) + "%",
          `Detection confidence`,
        ]);
        rows.push([
          "Sound Effects",
          `Effect ${index + 1} - Time`,
          `${formatTime(sound.timestamp?.start || 0)} - ${formatTime(sound.timestamp?.end || 0)}`,
          `When this sound occurs`,
        ]);
        rows.push([
          "Sound Effects",
          `Effect ${index + 1} - Description`,
          sound.description || "No description",
          `Detailed description`,
        ]);
      });

      // Add environment analysis
      if (data.soundEffects.environment) {
        const env = data.soundEffects.environment;
        rows.push([
          "Environment",
          "Location Type",
          env.location_type || "Unknown",
          "Indoor/outdoor classification",
        ]);
        rows.push([
          "Environment",
          "Setting",
          env.setting || "Unknown",
          "Environment setting type",
        ]);
        rows.push([
          "Environment",
          "Activity Level",
          env.activity_level || "Unknown",
          "Level of activity/busyness",
        ]);
        rows.push([
          "Environment",
          "Acoustic Space",
          env.acoustic_space || "Unknown",
          "Size of acoustic space",
        ]);
        rows.push([
          "Environment",
          "Time of Day",
          env.time_of_day || "Unknown",
          "Estimated time period",
        ]);
        rows.push([
          "Environment",
          "Weather",
          env.weather || "Unknown",
          "Weather conditions if detectable",
        ]);
      }
    }

    // Add Similar Tracks if available
    if (
      data.similarity &&
      data.similarity.similar_tracks &&
      data.similarity.similar_tracks.length > 0
    ) {
      data.similarity.similar_tracks.forEach((track, index) => {
        rows.push([
          "Similar Music",
          `Similar Track ${index + 1}`,
          `${track.artist} - ${track.title}`,
          `${Math.round(track.similarity * 100)}% similarity`,
        ]);
      });
      rows.push([
        "Similar Music",
        "Genre Confidence",
        Math.round((data.similarity.genre_confidence || 0) * 100) + "%",
        "Confidence in genre classification",
      ]);
    }

    // Add AI Tags
    if (data.tags && data.tags.length > 0) {
      rows.push([
        "AI Tags",
        "All Tags",
        data.tags.map((tag) => `#${tag}`).join(", "),
        `${data.tags.length} auto-generated tags for SEO and categorization`,
      ]);
    }

    // Add Transcription if available
    if (data.transcription && data.transcription.trim() && !data.transcription.toLowerCase().includes('no speech detected')) {
      const transcription = data.transcription.trim();
      rows.push([
        "Transcription",
        "Full Text",
        transcription,
        "Complete audio-to-text transcription",
      ]);
      rows.push([
        "Transcription",
        "Character Count",
        transcription.length.toString(),
        "Total characters in transcription",
      ]);
    }

    // Add Style Influences if available
    if (data.similarity && data.similarity.style_influences && data.similarity.style_influences.length > 0) {
      rows.push([
        "Similar Music",
        "Style Influences",
        data.similarity.style_influences.join(", "),
        "Musical styles that influenced this track",
      ]);
    }

    // Add AI Description
    if (data.aiDescription) {
      rows.push([
        "AI Analysis",
        "Description",
        data.aiDescription,
        "AI-generated description of the audio",
      ]);
    }

    // Helper function for time formatting
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    }

    return rows
      .map((row) =>
        row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(",")
      )
      .join("\n");
  }

  function generateTextReport(data) {
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };

    let report = `
COMPREHENSIVE AUDIO ANALYSIS REPORT
==================================

File Information:
- Filename: ${data.filename}
- Analysis Date: ${new Date(data.timestamp).toLocaleString()}
- Duration: ${formatTime(data.duration)}
- File Size: ${data.fileSize || "Unknown"}
- Format: ${data.format || "Unknown"}
- Processing Time: ${data.processingTime || 0} seconds

Musical Analysis:
- Genre: ${data.basicInfo?.genre || "Unknown"}
- Mood: ${data.basicInfo?.mood || "Unknown"}
- BPM: ${data.basicInfo?.bpm || "Unknown"}
- Key: ${data.basicInfo?.key || "Unknown"}
- Energy Level: ${Math.round((data.basicInfo?.energy || 0) * 100)}%
- Valence: ${Math.round((data.basicInfo?.valence || 0) * 100)}%
- Danceability: ${Math.round((data.basicInfo?.danceability || 0) * 100)}%
- Instrumentalness: ${Math.round((data.basicInfo?.instrumentalness || 0) * 100)}%
- Speechiness: ${Math.round((data.basicInfo?.speechiness || 0) * 100)}%
- Acousticness: ${Math.round((data.basicInfo?.acousticness || 0) * 100)}%
- Liveness: ${Math.round((data.basicInfo?.liveness || 0) * 100)}%

Audio Quality Assessment:
- Overall Score: ${data.quality?.overall || 0}/10
- Clarity: ${data.quality?.clarity || 0}/10
- Loudness: ${data.quality?.loudness || 0} dB
- Dynamic Range: ${data.quality?.dynamic_range || 0}/10
- Noise Level: ${data.quality?.noise_level || 0}%
- Distortion: ${data.quality?.distortion || 0}%
- Frequency Balance: ${data.quality?.frequency_balance || 0}/10
`;

    // Add Content Type Analysis
    if (data.contentType) {
      report += `
Content Type Analysis:
- Primary Type: ${data.contentType.primary}
- Classification Confidence: ${Math.round((data.contentType.confidence || 0) * 100)}%
- Description: ${data.contentType.description || "No description available"}
`;
    }

    // Add Emotional Analysis
    if (data.emotions) {
      report += `
Emotional Analysis:
${Object.entries(data.emotions)
  .map(
    ([emotion, value]) =>
      `- ${emotion.charAt(0).toUpperCase() + emotion.slice(1)}: ${Math.round((value as number) * 100)}%`
  )
  .join("\n")}
`;
    }

    // Add Voice Analysis
    if (data.voiceAnalysis && data.voiceAnalysis.hasVoice) {
      report += `
Voice & Speech Analysis:
- Voice Detected: Yes
- Speaker Count: ${data.voiceAnalysis.speakerCount || 0}
`;

      if (data.voiceAnalysis.genderDetection) {
        report += `- Primary Gender: ${data.voiceAnalysis.genderDetection.primary || "Unknown"} (${Math.round((data.voiceAnalysis.genderDetection.confidence || 0) * 100)}% confidence)
`;
      }

      if (data.voiceAnalysis.speakerEmotion) {
        report += `- Speaker Emotion: ${data.voiceAnalysis.speakerEmotion.primary || "Unknown"} (${Math.round((data.voiceAnalysis.speakerEmotion.confidence || 0) * 100)}% confidence)
`;
      }

      if (data.voiceAnalysis.speechClarity) {
        report += `- Speech Clarity: ${data.voiceAnalysis.speechClarity.score || 0}/10
- Speaking Pace: ${data.voiceAnalysis.speechClarity.pace || "Unknown"}
- Volume Level: ${data.voiceAnalysis.speechClarity.volume || "Unknown"}
`;
      }
    }

    // Add Sound Effects Analysis
    if (
      data.soundEffects &&
      data.soundEffects.detected &&
      data.soundEffects.detected.length > 0
    ) {
      report += `
Sound Effects Analysis:
${data.soundEffects.detected
  .map(
    (sound, index) =>
      `Effect ${index + 1}:
  - Type: ${sound.type || "Unknown"}
  - Category: ${sound.category || "Unknown"}
  - Confidence: ${Math.round((sound.confidence || 0) * 100)}%
  - Time: ${formatTime(sound.timestamp?.start || 0)} - ${formatTime(sound.timestamp?.end || 0)}
  - Description: ${sound.description || "No description"}`
  )
  .join("\n\n")}
`;

      // Add Environment Analysis
      if (data.soundEffects.environment) {
        const env = data.soundEffects.environment;
        report += `
Environment Analysis:
- Location Type: ${env.location_type || "Unknown"}
- Setting: ${env.setting || "Unknown"}
- Activity Level: ${env.activity_level || "Unknown"}
- Acoustic Space: ${env.acoustic_space || "Unknown"}
- Time of Day: ${env.time_of_day || "Unknown"}
- Weather: ${env.weather || "Unknown"}
`;
      }
    }

    // Add Similar Music Analysis
    if (
      data.similarity &&
      data.similarity.similar_tracks &&
      data.similarity.similar_tracks.length > 0
    ) {
      report += `
Similar Music Analysis:
- Genre Classification Confidence: ${Math.round((data.similarity.genre_confidence || 0) * 100)}%

Similar Tracks:
${data.similarity.similar_tracks
  .map(
    (track, index) =>
      `${index + 1}. ${track.artist} - ${track.title} (${Math.round(track.similarity * 100)}% similarity)`
  )
  .join("\n")}
`;
    }

    // Add AI Tags
    if (data.tags && data.tags.length > 0) {
      report += `
AI-Generated Tags (${data.tags.length} total):
${data.tags.map((tag) => `#${tag}`).join(", ")}
`;
    }

    // Add AI Description
    if (data.aiDescription) {
      report += `
AI-Generated Description:
${data.aiDescription}
`;
    }

    report += `

Generated by Describe Music - AI-Powered Audio Analysis
Report ID: ${data.id || "Unknown"}
`;

    return report.trim();
  }

  function generateSummary(data) {
    const cleanFilename = getCleanFilename(data.filename);

    let summary = `ðŸŽµ Audio Analysis Summary for: ${cleanFilename}

ðŸ“Š Basic Info: ${data.basicInfo?.genre || "Unknown"} | ${data.basicInfo?.mood || "Unknown"} | ${data.basicInfo?.bpm || "Unknown"} BPM | ${data.basicInfo?.key || "Unknown"}

âš¡ Key Metrics:
â€¢ Energy: ${Math.round((data.basicInfo?.energy || 0) * 100)}%
â€¢ Danceability: ${Math.round((data.basicInfo?.danceability || 0) * 100)}%
â€¢ Valence: ${Math.round((data.basicInfo?.valence || 0) * 100)}%
â€¢ Quality Score: ${data.quality?.overall || 0}/10

ðŸ“ File Info: ${data.format || "Unknown"} | ${data.fileSize || "Unknown"} | ${Math.floor((data.duration || 0) / 60)}:${Math.floor((data.duration || 0) % 60).toString().padStart(2, "0")}`;

    // Add Content Type if available
    if (data.contentType) {
      summary += `\n\nðŸŽ¯ Content Type: ${data.contentType.primary} (${Math.round((data.contentType.confidence || 0) * 100)}% confidence)`;
      if (data.contentType.description) {
        summary += `\n   ${data.contentType.description}`;
      }
    }

    // Add Voice Analysis if available
    if (data.voiceAnalysis && data.voiceAnalysis.hasVoice) {
      summary += `\n\nðŸŽ™ï¸ Voice Analysis:`;
      summary += `\nâ€¢ Speakers: ${data.voiceAnalysis.speakerCount || 0}`;
      if (data.voiceAnalysis.genderDetection) {
        summary += `\nâ€¢ Gender: ${data.voiceAnalysis.genderDetection.primary || "Unknown"} (${Math.round((data.voiceAnalysis.genderDetection.confidence || 0) * 100)}%)`;
      }
      if (data.voiceAnalysis.speakerEmotion) {
        summary += `\nâ€¢ Emotion: ${data.voiceAnalysis.speakerEmotion.primary || "Unknown"} (${Math.round((data.voiceAnalysis.speakerEmotion.confidence || 0) * 100)}%)`;
      }
      if (data.voiceAnalysis.speechClarity) {
        summary += `\nâ€¢ Speech Clarity: ${Math.round((data.voiceAnalysis.speechClarity.score || 0) * 10)}/10`;
        summary += ` | Pace: ${data.voiceAnalysis.speechClarity.pace || "normal"}`;
        summary += ` | Volume: ${data.voiceAnalysis.speechClarity.volume || "normal"}`;
      }
      if (data.voiceAnalysis.languageAnalysis) {
        summary += `\nâ€¢ Language: ${data.voiceAnalysis.languageAnalysis.language || "Unknown"} (${Math.round((data.voiceAnalysis.languageAnalysis.confidence || 0) * 100)}%)`;
        if (data.voiceAnalysis.languageAnalysis.accent) {
          summary += ` | Accent: ${data.voiceAnalysis.languageAnalysis.accent}`;
        }
      }
    }

    // Add Sound Effects if available
    if (
      data.soundEffects &&
      data.soundEffects.detected &&
      data.soundEffects.detected.length > 0
    ) {
      summary += `\n\nðŸ”Š Sound Effects: ${data.soundEffects.detected.length} detected`;
      data.soundEffects.detected.slice(0, 5).forEach((effect, index) => {
        const startTime = Math.floor(effect.timestamp?.start || 0);
        const endTime = Math.floor(effect.timestamp?.end || 0);
        summary += `\nâ€¢ ${index + 1}. ${effect.type || "Unknown"} (${effect.category || "Unknown"}) - ${Math.round((effect.confidence || 0) * 100)}%`;
        if (startTime > 0 || endTime > 0) {
          summary += ` [${Math.floor(startTime / 60)}:${Math.floor(startTime % 60).toString().padStart(2, "0")} - ${Math.floor(endTime / 60)}:${Math.floor(endTime % 60).toString().padStart(2, "0")}]`;
        }
        if (effect.description) {
          summary += `\n  ${effect.description}`;
        }
      });
      if (data.soundEffects.detected.length > 5) {
        summary += `\n  ... and ${data.soundEffects.detected.length - 5} more`;
      }
      if (data.soundEffects.environment) {
        summary += `\n\nðŸ“ Environment:`;
        if (data.soundEffects.environment.location_type) {
          summary += `\nâ€¢ Location: ${data.soundEffects.environment.location_type}`;
        }
        if (data.soundEffects.environment.setting) {
          summary += `\nâ€¢ Setting: ${data.soundEffects.environment.setting}`;
        }
        if (data.soundEffects.environment.activity_level) {
          summary += `\nâ€¢ Activity: ${data.soundEffects.environment.activity_level}`;
        }
      }
    }

    // Add All Emotions
    if (data.emotions) {
      const sortedEmotions = Object.entries(data.emotions)
        .sort(([, a], [, b]) => (b as number) - (a as number))
        .filter(([, value]) => (value as number) > 0);

      if (sortedEmotions.length > 0) {
        summary += `\n\nðŸŽ­ Emotions:`;
        sortedEmotions.forEach(([emotion, value]) => {
          summary += `\nâ€¢ ${emotion.charAt(0).toUpperCase() + emotion.slice(1)}: ${Math.round((value as number) * 100)}%`;
        });
      }
    }

    // Add Transcription if available
    if (data.transcription && data.transcription.trim() && !data.transcription.toLowerCase().includes('no speech detected')) {
      summary += `\n\nðŸ“ Transcription:`;
      const transcription = data.transcription.trim();
      // å¦‚æžœè½¬å½•å†…å®¹å¤ªé•¿ï¼Œå¯ä»¥æˆªæ–­ï¼Œä½†ä¿ç•™æ›´å¤šå†…å®¹
      if (transcription.length > 500) {
        summary += `\n${transcription.substring(0, 500)}...`;
        summary += `\n\n[Transcription truncated - ${transcription.length} characters total]`;
      } else {
        summary += `\n${transcription}`;
      }
    }

    // Add Similarity Analysis if available
    if (data.similarity) {
      if (data.similarity.similar_tracks && data.similarity.similar_tracks.length > 0) {
        summary += `\n\nðŸŽ¼ Similar Tracks:`;
        data.similarity.similar_tracks.slice(0, 3).forEach((track, index) => {
          summary += `\nâ€¢ ${index + 1}. ${track.title || "Unknown"} by ${track.artist || "Unknown"}`;
          if (track.similarity) {
            summary += ` (${Math.round(track.similarity * 100)}% similar)`;
          }
        });
      }
      if (data.similarity.style_influences && data.similarity.style_influences.length > 0) {
        summary += `\n\nðŸŽ¨ Style Influences: ${data.similarity.style_influences.join(", ")}`;
      }
    }

    // Add AI Tags (all tags)
    if (data.tags && data.tags.length > 0) {
      summary += `\n\nðŸ·ï¸ AI Tags: ${data.tags.map((tag) => `#${tag}`).join(" ")}`;
    }

    // Add Full AI Description (not truncated)
    if (data.aiDescription) {
      summary += `\n\nðŸ¤– AI Description:\n${data.aiDescription}`;
    }

    // Add Quality Details
    if (data.quality) {
      summary += `\n\nâ­ Quality Details:`;
      if (data.quality.clarity !== undefined) {
        summary += `\nâ€¢ Clarity: ${data.quality.clarity}/10`;
      }
      if (data.quality.loudness !== undefined) {
        summary += `\nâ€¢ Loudness: ${data.quality.loudness}/10`;
      }
      if (data.quality.dynamic_range !== undefined) {
        summary += `\nâ€¢ Dynamic Range: ${data.quality.dynamic_range}/10`;
      }
      if (data.quality.noise_level !== undefined) {
        summary += `\nâ€¢ Noise Level: ${data.quality.noise_level}/10`;
      }
    }

    summary += `\n\nâœ¨ Analyzed by Describe Music - AI-Powered Audio Analysis`;

    return summary;
  }

  function generateEmailBody(data) {
    const cleanFilename = getCleanFilename(data.filename);

    let emailBody = `I wanted to share comprehensive audio analysis results for "${cleanFilename}":

ðŸ“Š MUSICAL ANALYSIS:
ðŸŽµ Genre: ${data.basicInfo?.genre || "Unknown"}
ðŸŽ­ Mood: ${data.basicInfo?.mood || "Unknown"}
ðŸ¥ BPM: ${data.basicInfo?.bpm || "Unknown"}
ðŸŽ¹ Key: ${data.basicInfo?.key || "Unknown"}
âš¡ Energy: ${Math.round((data.basicInfo?.energy || 0) * 100)}%
ðŸ’« Valence: ${Math.round((data.basicInfo?.valence || 0) * 100)}%
ðŸ•º Danceability: ${Math.round((data.basicInfo?.danceability || 0) * 100)}%

ðŸŽ¯ AUDIO QUALITY:
â­ Overall Score: ${data.quality?.overall || 0}/10
ðŸ” Clarity: ${data.quality?.clarity || 0}/10
ðŸ“¢ Loudness: ${data.quality?.loudness || 0} dB
ðŸ“Š Dynamic Range: ${data.quality?.dynamic_range || 0}/10

ðŸ“ FILE INFO:
â±ï¸ Duration: ${Math.floor((data.duration || 0) / 60)}:${((data.duration || 0) % 60).toString().padStart(2, "0")}
ðŸ’¾ Size: ${data.fileSize || "Unknown"}
ðŸŽ§ Format: ${data.format || "Unknown"}`;

    // Add Content Type
    if (data.contentType) {
      emailBody += `\n\nðŸŽ¯ CONTENT TYPE:
ðŸ“‹ Type: ${data.contentType.primary} (${Math.round((data.contentType.confidence || 0) * 100)}% confidence)
ðŸ“ Description: ${data.contentType.description || "No description"}`;
    }

    // Add Voice Analysis
    if (data.voiceAnalysis && data.voiceAnalysis.hasVoice) {
      emailBody += `\n\nðŸŽ™ï¸ VOICE ANALYSIS:
ðŸ‘¥ Speakers: ${data.voiceAnalysis.speakerCount || 0}`;

      if (data.voiceAnalysis.genderDetection) {
        emailBody += `\nðŸ‘¤ Primary Gender: ${data.voiceAnalysis.genderDetection.primary || "Unknown"}`;
      }

      if (data.voiceAnalysis.speakerEmotion) {
        emailBody += `\nðŸ˜Š Speaker Emotion: ${data.voiceAnalysis.speakerEmotion.primary || "Unknown"}`;
      }
    }

    // Add Top Emotions
    if (data.emotions) {
      const topEmotions = Object.entries(data.emotions)
        .sort(([, a], [, b]) => (b as number) - (a as number))
        .slice(0, 5);

      if (topEmotions.length > 0) {
        emailBody += `\n\nðŸŽ­ EMOTIONAL ANALYSIS:
${topEmotions
  .map(
    ([emotion, value]) =>
      `${emotion.charAt(0).toUpperCase() + emotion.slice(1)}: ${Math.round((value as number) * 100)}%`
  )
  .join("\n")}`;
      }
    }

    // Add Sound Effects
    if (
      data.soundEffects &&
      data.soundEffects.detected &&
      data.soundEffects.detected.length > 0
    ) {
      emailBody += `\n\nðŸ”Š SOUND EFFECTS (${data.soundEffects.detected.length} detected):`;
      data.soundEffects.detected.slice(0, 3).forEach((sound, index) => {
        emailBody += `\n${index + 1}. ${sound.type || "Unknown"} (${Math.round((sound.confidence || 0) * 100)}% confidence)`;
      });
      if (data.soundEffects.detected.length > 3) {
        emailBody += `\n... and ${data.soundEffects.detected.length - 3} more`;
      }
    }

    // Add AI Tags
    if (data.tags && data.tags.length > 0) {
      const displayTags = data.tags.slice(0, 10);
      emailBody += `\n\nðŸ·ï¸ AI TAGS:
${displayTags.map((tag) => `#${tag}`).join(", ")}`;
      if (data.tags.length > 10) {
        emailBody += ` (+${data.tags.length - 10} more)`;
      }
    }

    emailBody += `\n\nâœ¨ Analyzed with Describe Music - AI-Powered Audio Analysis
ðŸŒ Try it yourself: ${window.location.origin}`;

    return emailBody;
  }

  function showNotification(message, type = 'success') {
    // Use toast system if available, otherwise fallback to simple notification
    if (window.addCreditToast) {
      window.addCreditToast({
        type: type === 'error' ? 'error' : 'success',
        title: type === 'error' ? 'Error' : type === 'success' ? 'Success' : 'Info',
        message: message,
        duration: type === 'error' ? 8000 : 5000
      });
    } else {
      // Fallback to simple notification
      const notification = document.createElement("div");
      notification.className =
        "fixed top-20 right-4 bg-green-500/90 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-all duration-300";
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.opacity = "0";
        setTimeout(() => document.body.removeChild(notification), 300);
      }, 3000);
    }
  }

  // Make all export and share functions globally accessible
  (window as any).exportAsJSON = exportAsJSON;
  (window as any).exportAsCSV = exportAsCSV;
  (window as any).exportReport = exportReport;
  (window as any).copyAnalysisData = copyAnalysisData;
  (window as any).copyShareLink = copyShareLink;
  (window as any).shareViaEmail = shareViaEmail;
  (window as any).shareToTwitter = shareToTwitter;
  (window as any).shareToLinkedIn = shareToLinkedIn;
  (window as any).generateSummary = generateSummary;
  (window as any).convertToCSV = convertToCSV;
</script>
